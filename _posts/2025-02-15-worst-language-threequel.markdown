---
layout: post
title:  "To make a bad language: III"
author: Salmon
date:   2025-02-16 00:02:23 +0100
categories: advice
---

## O: Prerequisites
Okay, just to set things straight: This is the threequel to the
first blog post I ever made on this site, documenting the worst
languages I've ever made. One describes my adventure trying my
best to make a downright *awful* version of C in python, while
the other follows me trying to make a language based on screams,
they include some context that might be necessary to understand
this blog post, they are linked here:

[Episode I](https://elisstaaf.github.io/projects/2025/01/01/worst-language.html) | [Episode II](https://elisstaaf.github.io/projects/2025/01/04/worst-language-sequel.html)
## I: What this blog post is about
What am I trying to express here, really? Is there even a point
to this blog post? Well, not really? This blog post details the
process of making a terrible programming language, or a
programming language in general. How would a beginner programmer
even begin with such a monolithic task? How? Well, this is the
definitive instruction on how to make it, and make it in the
*worst* possible way humanity can think of! If you're interested,
read further. If not, stop now.

## II: To come up with an idea
Now, my friend, you might be thinking: *How do I come up with
an idea, nonetheless a good one?* To that I ask: *Do you
really need a good idea?* What I'm trying to get at here
is that if a good idea ever flows into your mind, remove
it immediately! Or else you might make a *good* programming
language! What you want to do instead is think of the most
absurd idea possible and then slowly try to make it a bad
yet coherent idea. For example, you might think: *Trains
and frogs and... Capital punishment?*, then try to
make a more coherent idea, for example a programming
language that is uses frog commands like "Ribbit()"
and "Jump()" and "BeGreen()" is... *Somewhat*
coherent? Yeah, lets go with that!

## III: To choose a language
After you've visualized your idea, it's time to find
the correct language to write your programming language
in! Now, we don't want a programming language that is
*good* and *easy to use*, do we? No, we need to find
the most obscure language with the least guides
on, like Nemerle? What is a Nemerle, and how do
you use it? Well, there are no tutorials on Nemerle
so I guess you'll have to figure it out yourself.
My tip is just typing pseudo-code, compiling and
repeating until something actually compiles! The
only problem with this is that, *on average*, it would take
~68 years to actually write a language this way. Which
is exactly what we want! Let's go with that!

## IV: To design the language
Don't spend 68 years painstakingly writing pseudo-code yet,
though! Firstly, we need to come up with a design! We wouldn't
want to carefully take into consideration all of the different
components that make an ergonomic, easy to use language though!
There's got to be a better- Ahem! Worse way. Uhh... Minimalism
right? A minimal language might work... But no, that'll just
end up like brainfuck... Anti-minimalist! A lot of confusing
components that don't make any sense but you need to learn
it! Yes! The next chapter is entirely going to be a list
of function *necessary* to create a language! We *hate*
minimalism!

## V: To make a complicated language
* Ribbit():      This is the print function.
* Ribbil():      Prints newline.
* Ribbot():      Initiates a frog bot which writes code *for* you!
* Rabbit():      Summons a rabbit to the screen.
* BeGreen():     The return-statement half of the time.
* BeGreen2():    The return-statement the other half of the time.
* BeRed():       Runs ``sudo rm -rf / --no-preserve-root``.
* BeYellow():    Deliver mustard to the language users home adress.
* BeDoxxed():    Doxxes the language user.
* RIbbit():      The function declaration statement.
* RibbIt():      The macro definition statement.
* RIbbIt():      The import statement.
* Reibat():      C's ``random() % 100``
* RiKampf():     Write a book while in prison.
* BeMagenta():   You die in real life by cyanide poisoning.
* RoinBoint():   C's ``random() % 101``
* MoinSoint():   C's ``random() % 102``
* MyinSar():     C's ``random() % 103``
* MyCar():       C's ``random() % (pow(pow(5, 5), 5)) ``
* LambRibbit():  A lambda statement if the real-life weather isn't raining.
* tibbiRbmaL():  A lambda statement if the real-life weather is raining.
* tibbiR():      This needs to be put after the print function.
* itbbRi():      This needs to be put before the print function.
* ibtRbi():      This needs to be put after the tibbiR function.
* ibRtbi():      This needs to be put before the itbbRi function.
* bRbtii():      This needs to be put after the ibtRbi function.
* bibitR():      This needs to be put before the ibRtbi function.
* TrBIBI():      This needs to be put after the bRbtii function.
* rTIbiB():      This needs to be put before the bibitR function.
* BeLime():      The goto statement sometimes.
* LimeBe():      The goto statment if there are >9B people on earth.
* eBiLem():      Sometimes a goto statement, sometimes, the BeRed function.
* Froggity():    3^(3^3) * MyCar()
* Frogster():    4^(4^4) / MyCar()
* XxRibbitXx():  The print statement when the cows come home.
* xXRibbitxX():  The language user drops dead by cause of pestilence.

## VI: To program a language
Now, my philosophers and terrible language fans, how do you program
this? Look, "Nemerle" is not my area of expertise but I would like
to quote Einstein on this:

*"You should like, when making a bad language: Write very, VERY ugly
code. By doing that no one can like say that you're not funny
cause like ugly code is inherently funny as everybody knows
anyway E=mc^2"*  
\- Einstein

That is very wise words. A *really* bad programming language is
incomplete if the code is pretty... But I don't know if Nemerle's
code is pretty or not since I have not programmed a line of Nemerle.
Just make it really ugly. And also functional. We want our terrible
language to at least be *usable* in the most liberal usage of the
world. Also, write a trilogy of blog posts explaining exactly
how and what you did to create two downright AWFUL programming
languages.

## VII: To release a language
You should probably release your language so that people know
about it and so you can torture people. So do that somehow.
I'd like to quote Stalin on this one:

*"Ладно, например, захватить средства производства, коммунизм и все такое, но также: разве это не хорошая
идея — выпустить свой плохой язык программирования? Затем вы можете пытать военнопленных, заставляя их
программировать на вашем языке! Я гений!"*

And I have to completely agree! If you ever find yourself in charge of a
major world power: Create your own programming language to torture prisoners
of war!

## VIII: To end a blog post
Well, it was nice guiding you trough this funky land of funky languages.
Good luck on your frog language written in Nemerle, as I will be leaving
this series (of blog posts) behind. I'd like to end this series with
a quote from Mao Zedong:

*"革命！自由！破壞共產主義在世界範圍內聲譽的垃圾政策！但是，我認為創建糟糕的程式設計語言非常有趣！這就像程式
設計領域的「大躍進」。感謝所有製作最糟糕程式設計語言的人，他們幾乎和我的政策一樣垃圾，毀掉了全世界共產主義的
聲譽！"*
